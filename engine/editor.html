<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.59.0/codemirror.min.css" />
<link rel="stylesheet" href="https://uicdn.toast.com/editor/latest/toastui-editor.min.css" />
<style>
html {
  height: 100%;
  overflow: hidden;
}
body {
  margin: 0;
  height: 100%;
  display: flex;
  flex-direction: column;
  font-family: Sans-serif;
}
nav {
  display: flex;
  align-items: center;
}
nav .draft {
  color: rgba(0,0,0,0.6);
  padding: 5px 10px;
  border-radius: 2px;
  font-size: 14px;
}
.container {
  flex-grow: 1;
  display: flex;
}
#editor {
  flex-grow: 1;
}
.container iframe {
  border: none;
  width: 500px;
  height: 100%;
}
.flexible {
  flex-grow: 1;
}
.brand {
  text-decoration: none;
  font-size: 18px;
  font-weight: bold;
  color: rgba(0,0,0,0.8);
  font-family: Georgia;
  font-style: italic;
  margin: 0 10px;
}
.hidden {
  display: none;
}
nav button, nav .button {
  margin: 5px;
  padding: 5px 10px;
  border-radius: 2px;
  background: none;
  border: none;
  color: rgba(0,0,0,0.8);
  text-decoration: none;
  font-size: 14px;
  display: inline-block;
  cursor: pointer;
}
nav button.enabled, nav .button.enabled {
  background: rgba(0,0,0,0.8);
  color: white;
}
.menu-items {
  text-align: right;
}
.menu-items a {
  display: block;
  padding: 10px 15px;
  color: rgba(0,0,0,0.8);
  text-decoration: none;
  font-size: 14px;
}
.sidebar .file {
  cursor: pointer;
  padding: 10px;
  font-size: 14px;
  text-decoration: none;
  color: rgba(0,0,0,0.8);
  display: block;
}
.file.selected {
  background: rgba(0,0,0,0.1);
}
.swal2-content .images img {
  height: 100px;
  cursor: pointer;
  border: 3px solid white;
  box-sizing: border-box;
}
.swal2-content .images img.selected {
  border: 3px solid royalblue;
}
.swal2-content .publish-form > * {
  box-sizing: border-box;
  margin-bottom: 10px;
  width: 100%;
  padding: 10px;
  border-radius: 0;
  border: 1px solid rgba(0,0,0,0.2);
}
.swal2-content .publish-form textarea {
  height: 150px;
}
.swal2-content .publish-form .images {
  width: 100%;
  box-sizing: border-box;
  overflow: auto;
  padding: 0;
  text-align: left;
  border: none;
}
.swal2-styled.swal2-confirm {
  border-radius: 2px;
  background: rgba(0,0,0,0.8);
  color: white;
}
.swal2-modal {
  border-radius: 0;
}
</style>
</head>
<body>
<nav>
<a class='brand' href='./'>Offbase</a>
<button id='save' class='button'>save</button>
<button id='delete' class='button'>delete</button>
<div class='flexible'></div>
<div class='draft hidden'>private</div>
<button id='unpublish' class='enabled'>unpublish</button>
<button id='upload' class='enabled'>publish</button>
</nav>
<div class='container'>
  <div id='editor'></div>
</div>
<script type='module'>
import Editor from "https://jspm.dev/@toast-ui/editor"
import Swal from "https://jspm.dev/sweetalert2"
import matter from "https://jspm.dev/gray-matter"
import Handlebars from "https://jspm.dev/handlebars"
import marked from "https://jspm.dev/marked"
import RSS from "https://jspm.dev/rss"
import uslug from "https://jspm.dev/uslug"
import { fs, git } from "/offbase.js"
class Builder {
  constructor(config) {
    this.config = config
  }
  paginator (filenames, meta, template, CHUNK) {
    let pages = [];
    let counter = []
    for (let i=0; i<filenames.length; i+=CHUNK) {
      let page = filenames.slice(i, i + CHUNK)
      pages.push(page)
      counter.push({ number: i/CHUNK })
    }
    let res = []
    let index;
    for(let i=0; i<pages.length; i++) {
      counter[i].current = true;
      let html = template({
        title: this.config.NAME,
        base: "../../",
        items: pages[i].map((filename) => {
          return {
            filename: filename,
            meta: meta[filename]
          }
        }),
        pages: counter
      })
      res.push(html)

      if (i === 0) {
        index = template({
          title: this.config.NAME,
          base: "./",
          items: pages[i].map((filename) => {
            return {
              filename: filename,
              meta: meta[filename]
            }
          }),
          pages: counter
        })
      }
      counter[i].current = false;
    }
    return { index: index, pages: res }
  }
  async buildPost (key) {
    let tps = await fs.promises.readFile(this.config.THEME.POST, "utf8")
    let tpl = Handlebars.compile(tps)
    let contentPath = `${this.config.SRC}/${key}`
    let content = await fs.promises.readFile(contentPath, "utf8")
    let parsed = matter(content)
    let md = parsed.content
    let metadata = parsed.data
    metadata.permalink = key
    // Build Rendered Markdown HTML
    let html;
    if (this.config.FEED.BASE.length === 0) {
      html = marked(md, { baseUrl: "../" }) 
    } else {
      html = marked(md, { baseUrl: this.config.FEED.BASE }) 
    }
    // createa hidden dom
    let div = document.createElement("div")
    div.innerHTML = html
    let images = []
    div.querySelectorAll("img").forEach((el) => {
      images.push(el.getAttribute("src"))
    })

    // copy all assets
    for(let image of images) {
      let match = /assets\/(.+)$/.exec(image)
      if (match && match.length > 0) {
        let assetPath = `${this.config.SRC}/assets/${match[1]}`
        let b = await fs.promises.readFile(assetPath)
        await fs.promises.writeFile(`${this.config.SRC}/assets/${match[1]}`, b)
      }
    }
    // Build full HTML page
    let rendered = tpl({
      name: this.config.NAME,
      content: html,
      updated: metadata.updated,
      filename: `${this.config.SRC}/${key}`,
      title: metadata.title
    }).trim()

    // Write to the post folder
    await fs.promises.mkdir(this.config.DEST).catch((e) => { })
    await fs.promises.mkdir(`${this.config.DEST}/${key}`).catch((e) => { })
    await fs.promises.writeFile(`${this.config.DEST}/${key}/index.html`, rendered)

    return { html, metadata }
  }
  async build () {
    // Create folders in case they're empty
    await fs.promises.mkdir(this.config.DEST).catch((e) => {})
    await fs.promises.mkdir(`${this.config.DEST}/pages`).catch((e) => {})
    await fs.promises.mkdir(`${this.config.DEST}/assets`).catch((e) => {})

    // Instantiate templates
    let tds = await fs.promises.readFile(this.config.THEME.HOME, "utf8")
    let tps = await fs.promises.readFile(this.config.THEME.POST, "utf8")
    let tpl = Handlebars.compile(tds)

    // Do RSS only when there's custom BASE URL
    // Instantiate RSS
    let feed = new RSS()

    let filenames = []
    let meta = {}
    let src = await fs.promises.readdir(this.config.SRC)
    let promises = src.filter((key) => { return key !== "assets" }).map((key) => {
      return new Promise(async (resolve, reject) => {
        let { html, metadata } = await this.buildPost(key) 
        meta[key] = metadata
        if (metadata.draft) {
          await fs.promises.unlink(`${this.config.DEST}/${key}/index.html`)
        } else {
          filenames.push(key)
        }
        if (feed.items.length < this.config.FEED.CHUNK) {
          feed.item({
            title: metadata.title,
            description: html,
            url: `${this.config.FEED.BASE}${key}`,
            date: metadata.updated
          })
        }
        resolve()
      })
    })
    await Promise.all(promises)

    // build assets
    await fs.promises.mkdir(`${this.config.SRC}/assets`).catch((e) => { })
    let assets = await fs.promises.readdir(`${this.config.SRC}/assets`)
    for(let file of assets) { 
      let b = await fs.promises.readFile(`${this.config.SRC}/assets/${file}`)
      await fs.promises.writeFile(`${this.config.DEST}/assets/${file}`, b)
    }

    let xml = feed.xml({ indent: true });
    await fs.promises.writeFile(`${this.config.DEST}/rss.xml`, xml)
    filenames.sort((a, b) => {
      return parseInt(meta[b].updated) - parseInt(meta[a].updated);
    })
    await fs.promises.mkdir(`${this.config.DEST}/pages`).catch((e) => { })
    // build pages
    let { index, pages } = await this.paginator(filenames, meta, tpl, this.config.PAGE.CHUNK)
    for(let i=0; i<pages.length; i++) {
      await fs.promises.mkdir(`${this.config.DEST}/pages/${i}`).catch((e) => { })
      await fs.promises.writeFile(`${this.config.DEST}/pages/${i}/index.html`, pages[i]).catch((e) => { })
    }
    await fs.promises.writeFile(`${this.config.DEST}/index.html`, index)
  }
}
class E {
  constructor (o) {
    this.src = o.src
    this.config = o.config
    this.builder = new Builder(o.config)
    this.editor = new Editor({
      frontMatter: true,
      el: document.querySelector('#editor'),
      height: '100%',
      initialEditType: 'markdown',
      usageStatistics: false,
      previewStyle: 'vertical',
      events: {
        change: () => {
          document.querySelector("#save").classList.add("enabled")
        }
      },
      hooks: {
        addImageBlobHook: async (blob, callback) => {
          let ab = await blob.arrayBuffer()
          let bytes = new Uint8Array(ab)
          const hashBuffer = await crypto.subtle.digest('SHA-256', bytes)
          const hashArray = Array.from(new Uint8Array(hashBuffer));
          const hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
          await fs.promises.mkdir(this.config.SRC).catch((e) => { })
          await fs.promises.mkdir(`${this.config.SRC}/assets`).catch((e) => { })
          await fs.promises.writeFile(`${this.config.SRC}/assets/${hash}`, bytes).catch((e) => { })
          callback("assets/" + hash, hash)
          return false;
        }
      }
    });
    if (src) this.fill(decodeURIComponent(src))
  }
  fill (path) {
    fs.promises.readFile(path, "utf8").then((str) => {
      this.editor.setMarkdown(str)
      let parsed = matter(str)
      let md = parsed.content
      let metadata = parsed.data
      if (metadata.draft) {
        document.querySelector("#unpublish").classList.add("hidden")
        document.querySelector(".draft").classList.remove("hidden")
      }
    }).catch((e) => {
      console.log("error", e)
    })
  }
  async updated () {
    const FILE = 0, HEAD = 1, WORKDIR = 2, STAGE = 3
    let matrix = await git.statusMatrix({ fs, dir: "/home" })
    const filenames = matrix.filter((row) => { return !(row[HEAD] === 1 && row[WORKDIR] === 1 && row[STAGE] === 1) }).map(row => row[FILE])
    return filenames.length > 0
  }
  async deleted () {
    const FILE = 0, HEAD = 1, WORKDIR = 2, STAGE = 3
    let matrix = await git.statusMatrix({ fs, dir: "/home" })
    return matrix.filter((row) => { return row[WORKDIR] === 0 })
  }
  content() {
    let raw = this.editor.getMarkdown()
    let parsed = matter(raw)
    let md = parsed.content
    let metadata = parsed.data
    return { metadata, md, raw }
  }
  async unpublish() {
    let { md, metadata } = this.content()
    metadata.draft = true
    let updatedContent = matter.stringify(md, metadata)
    await fs.promises.writeFile(this.src, updatedContent)
    await this.builder.build()
    setTimeout(() => {
      location.href = "/upload"
    }, 1000)
  }
  async publish() {
    let { md, metadata } = this.content()
    metadata.draft = false;
    let updatedContent = matter.stringify(md, metadata)
    await fs.promises.writeFile(this.src, updatedContent)
    let isupdated = await this.updated()
    if (!isupdated) {
      console.log("no update")
      alert("no update")
      return;
    }
    await this.builder.build()
    setTimeout(() => {
      location.href = "/upload"
    }, 1000)
  }
  async save() {
    let { md, metadata, raw } = this.content()
    let matches = raw.matchAll(/!\[.*?\]\((.*?)\)/g)
    let images = []
    for (let match of matches) {
      images.push(match[1])
    }
    let imageTags = images.map((image, i) => {
      return (i === 0 ?  `<img class='selected' src='${image}'>` : `<img src='${image}'>`)
    }).join("")
    let desc = (metadata.description ? metadata.description : document.querySelector(".tui-editor-contents").textContent.trim().replace(/(\r\n|\n|\r)/gm,"").slice(0, 300))
    let {title, description, image} = await Swal.fire({
      title: 'Save',
      html: `<form class='publish-form'>
  <input class='title' type='text' placeholder='enter title' value='${metadata.title ? metadata.title : ""}'>
  <textarea class='description'>${desc}</textarea>
  <div class='images'>${imageTags}</div>
  </form>`,
      confirmButtonText: 'Save',
      didOpen: (el) => {
        el.querySelector(".images").addEventListener("click", (e) => {
          document.querySelectorAll(".images img").forEach((el2) => {
            el2.classList.remove("selected")
          })
          if (e.target.getAttribute("src")) e.target.classList.toggle("selected")
        })
      },
      preConfirm: async () => {
        let image = document.querySelector(".publish-form .images img.selected")
        let title = document.querySelector(".publish-form .title").value
        if (!title || title.length === 0) {
          alert("please enter title")
          return false;
        }
        try {
          // the first time creating a file,
          if (!this.src) {
            //does the title already exist?
            let slug = title.split().join("-").toLowerCase()
            let f = await fs.promises.stat(`${this.config.SRC}/${slug}`)
            // if already exists, return false
            alert("the file already exists")
            return false;
          }
        } catch (e) {
        }
        return [
          document.querySelector(".publish-form .title").value,
          document.querySelector(".publish-form .description").value,
          (image ? image.getAttribute("src") : null)
        ]
      }
    }).then((res) => {
      return {
        title: res.value[0],
        description: res.value[1],
        image: res.value[2]
      }
    })
    metadata.title = title
    metadata.description = description
    metadata.image = image
    metadata.updated = Date.now()
    let name
    let redirect = false;
    if (this.src) {
      name = this.src.split("/")[3]
    } else {
      name = uslug(title)
      this.src = `${this.config.SRC}/${name}`
      redirect = true;
    }
    metadata.permalink = name;
    let updatedContent = matter.stringify(md, metadata)
    await fs.promises.mkdir(this.config.SRC).catch((e) => { })
    await fs.promises.writeFile(`${this.config.SRC}/${metadata.permalink}`, updatedContent)
    document.querySelector("#save").classList.remove("enabled")
    if (redirect) {
      setTimeout(() => {
        location.href = "./editor?src=" + this.src
      }, 1000)
    } else {
      this.editor.setMarkdown(updatedContent)
    }
  }
  async destroy() {
    if (!this.src) return;
    let sure = confirm("are you sure?")
    if (sure) {
      // Delete files
      await fs.promises.unlink(this.src)
      let name = this.src.split("/")[2]
      await fs.promises.unlink(`${this.config.SRC}/${name}/index.html`).catch((e) => { })
      await fs.promises.rmdir(`${this.config.SRC}/${name}`).catch((e) => {})
      // remove from git too.
      let d = await this.deleted()
      for(let item of d) {
        await git.remove({ fs, dir: "/home", filepath: item[0] })
      }
      // Build
      await this.builder.build()
      setTimeout(() => {
        location.href = "/upload"
      }, 1000)
    }
  }
}
var src = new URL(location.href).searchParams.get("src")
fs.promises.readFile("/home/offbase.json", "utf8").then((o) => {
  let config = JSON.parse(o)
  var editor = new E({ src: src, config: config.settings })
  document.querySelector("#delete").addEventListener("click", async (e) => {
    await editor.destroy()
  })
  document.querySelector("#unpublish").addEventListener("click", async (e) => {
    await editor.unpublish() 
  })
  document.querySelector("#upload").addEventListener("click", async (e) => {
    await editor.publish()
  })
  document.querySelector("#save").addEventListener("click", async (e) => {
    await editor.save()
  });
})
</script>
</body>
</html>
