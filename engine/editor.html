<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.59.0/codemirror.min.css" />
<link rel="stylesheet" href="https://uicdn.toast.com/editor/latest/toastui-editor.min.css" />
<link rel='stylesheet' href="./style.css">
</head>
<body>
<nav>
<a class='brand' href='./'>Offbase</a>
<button id='save' class='button'>save</button>
<button id='delete' class='button'>delete</button>
<div class='flexible'></div>
<div class='draft hidden'>private</div>
<button id='unpublish' class='enabled'>unpublish</button>
<button id='upload' class='enabled'>publish</button>
</nav>
<div class='container'>
  <div id='editor'></div>
</div>
<script type='module'>
import Editor from "https://jspm.dev/@toast-ui/editor"
import Swal from "https://jspm.dev/sweetalert2"
import matter from "https://jspm.dev/gray-matter"
import { fs, git } from "/offbase.js"
import { builder, build } from "./builder.js"
var editor
var M
var src = new URL(location.href).searchParams.get("src")
const slugify = (string) => {
  const a = 'àáâäæãåāăąçćčđďèéêëēėęěğǵḧîïíīįìłḿñńǹňôöòóœøōõőṕŕřßśšşșťțûüùúūǘůűųẃẍÿýžźż·/_,:;'
  const b = 'aaaaaaaaaacccddeeeeeeeegghiiiiiilmnnnnoooooooooprrsssssttuuuuuuuuuwxyyzzz------'
  const p = new RegExp(a.split('').join('|'), 'g')
  return string.toString().toLowerCase()
    .replace(/\s+/g, '-') // Replace spaces with -
    .replace(p, c => b.charAt(a.indexOf(c))) // Replace special characters
    .replace(/&/g, '-and-') // Replace & with 'and'
    .replace(/[^\w\-]+/g, '') // Remove all non-word characters
    .replace(/\-\-+/g, '-') // Replace multiple - with single -
    .replace(/^-+/, '') // Trim - from start of text
    .replace(/-+$/, '') // Trim - from end of text
}
const render = async () => {
  editor = new Editor({
    frontMatter: true,
    el: document.querySelector('#editor'),
    height: '100%',
    initialEditType: 'markdown',
    usageStatistics: false,
    previewStyle: 'vertical',
    events: {
      change: () => {
        document.querySelector("#save").classList.add("enabled")
      }
    },
    hooks: {
      addImageBlobHook: async (blob, callback) => {
        let ab = await blob.arrayBuffer()
        let bytes = new Uint8Array(ab)
        const hashBuffer = await crypto.subtle.digest('SHA-256', bytes)
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        await fs.promises.mkdir(M.config.path.src.assets).catch((e) => {
          console.log("e", e)
        })
        await fs.promises.writeFile(M.config.path.src.assets + "/" + hash, bytes).catch((e) => {
          console.log("e", e)
        })
        callback("assets/" + hash, hash)
        return false;
      }
    }
  });
}
const fill = async (path) => {
  let str;
  let str = await fs.promises.readFile(path, "utf8").catch((e) => {
    console.log("error", e)
  })
  if (str) editor.setMarkdown(str)
  let parsed = matter(str)
  let md = parsed.content
  let metadata = parsed.data
  if (metadata.draft) {
    document.querySelector("#unpublish").classList.add("hidden")
    document.querySelector(".draft").classList.remove("hidden")
  }
}
const updated = async () => {
  const FILE = 0, HEAD = 1, WORKDIR = 2, STAGE = 3
  const filenames = (await git.statusMatrix({ fs, dir: "/" }))
    .filter((row) => {
      return !(row[HEAD] === 1 && row[WORKDIR] === 1 && row[STAGE] === 1)
    })
    .map(row => row[FILE])
  return filenames.length > 0
}
const deleted = async () => {
  const FILE = 0, HEAD = 1, WORKDIR = 2, STAGE = 3
  const filenames = (await M.git.statusMatrix({ fs, dir: "/" }))
    .filter((row) => {
      return row[WORKDIR] === 0
    })
  return filenames
}
document.querySelector("#delete").addEventListener("click", async (e) => {
  if (src) {
    let sure = confirm("are you sure?")
    if (sure) {
      // delete the file
      await fs.promises.unlink(src)

      // delete the corresponding dest files
      let name = src.split("/")[2]
      await fs.promises.unlink(M.config.path.dest.content + "/" + name + "/index.html").catch((e) => { })
      await fs.promises.rmdir(M.config.path.dest.content + "/" + name).catch((e) => {})

      // remove from git too.
      let d = await deleted()
      for(let item of d) {
        await M.git.remove({ fs, dir: "/home", filepath: item[0] })
        console.log("removed", item[0])
      }
      await builder(M, fs)
      setTimeout(() => {
        location.href = "/upload"
      }, 1000)
    }
  }
})
document.querySelector("#unpublish").addEventListener("click", async (e) => {
  let content = editor.getMarkdown()
  let parsed = matter(content)
  let md = parsed.content
  let metadata = parsed.data
  metadata.draft = true
  console.log("metadata = ", metadata)
  content = matter.stringify(md, metadata)
  await fs.promises.writeFile(src, content)
  await builder(M, fs)
  setTimeout(() => {
    location.href = "/upload"
  }, 1000)
})
document.querySelector("#upload").addEventListener("click", async (e) => {
  // Get content
  let content = editor.getMarkdown()
  let parsed = matter(content)
  let md = parsed.content
  let metadata = parsed.data
  metadata.draft = false;
  console.log("metadata = ", metadata)
  content = matter.stringify(md, metadata)
  await fs.promises.writeFile(src, content)

  let isupdated = await updated()
  if (!isupdated) {
    console.log("no update")
    alert("no update")
    return;
  }
  console.log("updated")

  await builder(M, fs)
  location.href = "/upload"
})
document.querySelector("#save").addEventListener("click", async (e) => {
  let content = editor.getMarkdown()

  let parsed = matter(content)
  let md = parsed.content
  let metadata = parsed.data

  console.log("metadata = ", metadata)
  // title
  // description
  // image preview
  // timestamp

  let matches = content.matchAll(/!\[.*?\]\((.*?)\)/g)
  let images = []
  for (let match of matches) {
    images.push(match[1])
  }
  let imageTags = images.map((image, i) => {
    if (i === 0) {
      return "<img class='selected' src='" + image + "'>"
    } else {
      return "<img src='" + image + "'>"
    }
  }).join("")

  let desc = (metadata.description ? metadata.description : document.querySelector(".tui-editor-contents").textContent.trim().replace(/(\r\n|\n|\r)/gm,"").slice(0, 300))
  let {title, description, image} = await Swal.fire({
    title: 'Save',
    html: `<form class='publish-form'>
<input class='title' type='text' placeholder='enter title' value='${metadata.title ? metadata.title : ""}'>
<textarea class='description'>${desc}</textarea>
<div class='images'>${imageTags}</div>
</form>`,
    confirmButtonText: 'Save',
    didOpen: (el) => {
      el.querySelector(".images").addEventListener("click", (e) => {
        document.querySelectorAll(".images img").forEach((el2) => {
          el2.classList.remove("selected")
        })
        if (e.target.getAttribute("src")) {
          e.target.classList.toggle("selected")
        }
      })
    },
    preConfirm: async () => {
      let image = document.querySelector(".publish-form .images img.selected")
      let title = document.querySelector(".publish-form .title").value
      if (!title || title.length === 0) {
        alert("please enter title")
        return false;
      }
      try {
        // the first time creating a file,
        if (!src) {
          //does the title already exist?
          let slug = title.split().join("-").toLowerCase()
          let f = await fs.promises.stat(M.config.path.src.content + "/" + slug)
          // if already exists, return false
          alert("the file already exists")
          return false;
        }
      } catch (e) {
      }
      return [
        document.querySelector(".publish-form .title").value,
        document.querySelector(".publish-form .description").value,
        (image ? image.getAttribute("src") : null)
      ]
    }
  }).then((res) => {
    return {
      title: res.value[0],
      description: res.value[1],
      image: res.value[2]
    }
  })
  console.log("title", title)
  console.log("description", description)
  console.log("image", image)
  metadata.title = title
  metadata.description = description
  metadata.image = image
  metadata.updated = Date.now()

  let name
  let redirect = false;
  if (src) {
    name = src.split("/")[3]
  } else {
    name = slugify(title)
    src = M.config.path.src.content + "/" + name
    //src = name
    redirect = true;
  }
  //metadata.permalink = name.split().join("-").toLowerCase()
  metadata.permalink = name

  // if draft attribute does not exist, set it to true
  // otherwise, ignore
  if (!metadata.hasOwnProperty("draft")) {
    metadata.draft = true
  }

  content = matter.stringify(md, metadata)

  await fs.promises.writeFile(M.config.path.src.content + "/" + metadata.permalink, content)


  //await builder(fs)
  console.log("start build")
  await build(M, fs, metadata.permalink)
  console.log("built")

  document.querySelector("#save").classList.remove("enabled")
  if (redirect) {
    setTimeout(() => {
      location.href = "./editor?src=" + src
    }, 1000)
  } else {
    editor.setMarkdown(content)
  }
});


(async () => {
  M = {
    config: {
      path: {
        src: {
          content: "/home/src",
          assets: "/home/src/assets"
        },
        dest: {
          content: "/home/blog",
          assets: "/home/blog/assets"
        }
      },
      settings: {
        name: "fingertwiddler",
        base: "https://fingertwiddler.github.io/test/blog/"
      }
    }
  }
  render()
  if (src) fill(decodeURIComponent(src))
})();

</script>
</body>
</html>
