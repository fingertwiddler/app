<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.59.0/codemirror.min.css" />
<link rel="stylesheet" href="https://uicdn.toast.com/editor/latest/toastui-editor.min.css" />
<style>
html {
  height: 100%;
  overflow: hidden;
}
body {
  margin: 0;
  height: 100%;
  display: flex;
  flex-direction: column;
  font-family: Sans-serif;
}
nav {
  display: flex;
  align-items: center;
}
nav .draft {
  color: rgba(0,0,0,0.6);
  padding: 5px 10px;
  border-radius: 2px;
  font-size: 14px;
}
.container {
  flex-grow: 1;
  display: flex;
}
#editor {
  flex-grow: 1;
}
.container iframe {
  border: none;
  width: 500px;
  height: 100%;
}
.flexible {
  flex-grow: 1;
}
.brand {
  text-decoration: none;
  font-size: 18px;
  font-weight: bold;
  color: rgba(0,0,0,0.8);
  font-family: Georgia;
  font-style: italic;
  margin: 0 10px;
}
.hidden {
  display: none;
}
nav button, nav .button {
  margin: 5px;
  padding: 5px 10px;
  border-radius: 2px;
  background: none;
  border: none;
  color: rgba(0,0,0,0.8);
  text-decoration: none;
  font-size: 14px;
  display: inline-block;
  cursor: pointer;
}
nav button.enabled, nav .button.enabled {
  background: rgba(0,0,0,0.8);
  color: white;
}
.menu-items {
  text-align: right;
}
.menu-items a {
  display: block;
  padding: 10px 15px;
  color: rgba(0,0,0,0.8);
  text-decoration: none;
  font-size: 14px;
}
.sidebar .file {
  cursor: pointer;
  padding: 10px;
  font-size: 14px;
  text-decoration: none;
  color: rgba(0,0,0,0.8);
  display: block;
}
.file.selected {
  background: rgba(0,0,0,0.1);
}
.swal2-content .images img {
  height: 100px;
  cursor: pointer;
  border: 3px solid white;
  box-sizing: border-box;
}
.swal2-content .images img.selected {
  border: 3px solid royalblue;
}
.swal2-content .publish-form > * {
  box-sizing: border-box;
  margin-bottom: 10px;
  width: 100%;
  padding: 10px;
  border-radius: 0;
  border: 1px solid rgba(0,0,0,0.2);
}
.swal2-content .publish-form textarea {
  height: 150px;
}
.swal2-content .publish-form .images {
  width: 100%;
  box-sizing: border-box;
  overflow: auto;
  padding: 0;
  text-align: left;
  border: none;
}
.swal2-styled.swal2-confirm {
  border-radius: 2px;
  background: rgba(0,0,0,0.8);
  color: white;
}
.swal2-modal {
  border-radius: 0;
}
</style>
</head>
<body>
<nav>
<a class='brand' href='./'>Offbase</a>
<button id='save' class='button'>save</button>
<button id='delete' class='button'>delete</button>
<div class='flexible'></div>
<div class='draft hidden'>private</div>
<button id='unpublish' class='enabled'>unpublish</button>
<button id='upload' class='enabled'>publish</button>
</nav>
<div class='container'>
  <div id='editor'></div>
</div>
<script type='module'>
import Editor from "https://jspm.dev/@toast-ui/editor"
import Swal from "https://jspm.dev/sweetalert2"
import matter from "https://jspm.dev/gray-matter"
import Handlebars from "https://jspm.dev/handlebars"
import marked from "https://jspm.dev/marked"
import uslug from "https://jspm.dev/uslug"
import { fs, git } from "/offbase.js"
class Builder {
  constructor(o) {
    this.config = o.config
//    this.modules = o.modules
    this.src = o.src
  }
  /***********************************************************************
  *
  * Input:
  *   - content filename
  *   - theme filename
  *
  * Output:
  *   - jjj
  ***********************************************************************/
  async processImages(content, config) {
    let re = /(?:!\[(.*?)\]\((.*?)\))/g
    let matches = content.matchAll(re)
    for(let m of matches) {
      let url = m[2]
      let match = /assets\/(.+)$/.exec(url)
      if (match && match.length > 0) {
        let b = await fs.promises.readFile(`${config.SRC}/assets/${match[1]}`)
        await fs.promises.writeFile(`${config.DEST}/assets/${match[1]}`, b)
      }
    }


  /*
    let div = document.createElement("div")
    div.innerHTML = html
    let images = div.querySelectorAll("img").map((el) => {
      return el.getAttribute("src")
    })
    // copy all assets to DEST
    for(let image of images) {
      let match = /assets\/(.+)$/.exec(image)
      if (match && match.length > 0) {
        let assetPath = `${config.SRC}/assets/${match[1]}`
        let b = await fs.promises.readFile(assetPath)
        await fs.promises.writeFile(`${config.DEST}/assets/${match[1]}`, b)
      }
    }
    */
  }
  async buildPost (filename, config) {

    // parse markdown metadata
    let md = await fs.promises.readFile(`${config.SRC}/${filename}`, "utf8")
    let { content, data } = matter(md)
    data.permalink = filename
    // build html from markdown
    let html = marked(content, { baseUrl: "../" }) 
    // extract images and write to DEST folder
    //this.processImages(html)
    this.processImages(content, config)

    // Build full HTML page for the post and write to DEST
    let theme = await fs.promises.readFile(config.THEME.POST, "utf8")
    let template = Handlebars.compile(theme)
    let rendered = template({
      name: config.NAME,
      content: html,
      updated: data.updated,
      filename: `${config.SRC}/${filename}`,
      title: data.title
    }).trim()
    await fs.promises.mkdir(`${config.DEST}/${filename}`).catch((e) => { })
    await fs.promises.writeFile(`${config.DEST}/${filename}/index.html`, rendered)

    return { html, data }
  }
  async getPost (key) {
    let md = await fs.promises.readFile(`${this.config.SRC}/${key}`, "utf8")
    return matter(md)
  }
  async build () {
    let src = await fs.promises.readdir(this.config.SRC)
    let items = await Promise.all(src.filter((key) => { return key !== "assets" }).map((key) => {
      return new Promise(async (resolve, reject) => {
        let { content, data } = await this.getPost(key) 
        resolve({
          key: key,
          data: data,
          content: content
        })
      })
    }))
    let publicItems = []
    for(let item of items) {
      if (item.data.draft) {
        await fs.promises.unlink(`${this.config.DEST}/${key}/index.html`)
      } else {
        publicItems.push(item)
      }
    }
    publicItems.sort((a, b) => {
      return parseInt(b.data.updated) - parseInt(a.data.updated);
    })

    let modules = await Promise.all(this.config.events.publish.map((mod) => {
      return import(`./module/${mod}`)
    }))
    for(let mod of modules) {
      await mod(publicItems, this.config, {
        fs, git
      })
    }
  }
}
class E {
  constructor (o) {
    this.src = o.src
    this.config = o.config
    this.builder = new Builder(o)
    this.editor = new Editor({
      frontMatter: true,
      el: document.querySelector('#editor'),
      height: '100%',
      initialEditType: 'markdown',
      usageStatistics: false,
      previewStyle: 'vertical',
      events: {
        change: () => {
          document.querySelector("#save").classList.add("enabled")
        }
      },
      hooks: {
        addImageBlobHook: async (blob, callback) => {
          let ab = await blob.arrayBuffer()
          let bytes = new Uint8Array(ab)
          const hashBuffer = await crypto.subtle.digest('SHA-256', bytes)
          const hashArray = Array.from(new Uint8Array(hashBuffer));
          const hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
          await fs.promises.writeFile(`${this.config.SRC}/assets/${hash}`, bytes).catch((e) => { console.log("error", e) })
          callback("assets/" + hash, hash)
          return false;
        }
      }
    });
    if (src) this.fill(decodeURIComponent(src))
  }
  fill (path) {
    fs.promises.readFile(path, "utf8").then((str) => {
      this.editor.setMarkdown(str)
      let { data, content } = matter(str)
      if (data.draft) {
        document.querySelector("#unpublish").classList.add("hidden")
        document.querySelector(".draft").classList.remove("hidden")
      }
    }).catch((e) => {
      console.log("error", e)
    })
  }
  async updated () {
    const FILE = 0, HEAD = 1, WORKDIR = 2, STAGE = 3
    let matrix = await git.statusMatrix({ fs, dir: "/home" })
    const filenames = matrix.filter((row) => { return !(row[HEAD] === 1 && row[WORKDIR] === 1 && row[STAGE] === 1) }).map(row => row[FILE])
    return filenames.length > 0
  }
  async deleted () {
    const FILE = 0, HEAD = 1, WORKDIR = 2, STAGE = 3
    let matrix = await git.statusMatrix({ fs, dir: "/home" })
    return matrix.filter((row) => { return row[WORKDIR] === 0 })
  }
  content() {
    let raw = this.editor.getMarkdown()
    let { content, data } = matter(raw)
    return { content, data, raw }
  }
  async unpublish() {
    let { content, data } = this.content()
    data.draft = true
    let updatedContent = matter.stringify(content, data)
    await fs.promises.writeFile(this.src, updatedContent)
    await this.builder.build()
    location.href = "/upload"
  }
  async publish() {
    let { content, data } = this.content()
    data.draft = false;
    let updatedContent = matter.stringify(content, data)
    await fs.promises.writeFile(this.src, updatedContent)
    let isupdated = await this.updated()
    if (!isupdated) {
      console.log("no update")
      alert("no update")
      return;
    }
    await this.builder.build()
    location.href = "/upload"
  }
  async save() {
    let { content, data, raw } = this.content()
    let matches = raw.matchAll(/!\[.*?\]\((.*?)\)/g)
    let images = []
    for (let match of matches) {
      images.push(match[1])
    }
    let imageTags = images.map((image, i) => {
      return (i === 0 ?  `<img class='selected' src='${image}'>` : `<img src='${image}'>`)
    }).join("")
    let desc = (data.description ? data.description : document.querySelector(".tui-editor-contents").textContent.trim().replace(/(\r\n|\n|\r)/gm,"").slice(0, 300))
    let {title, description, image} = await Swal.fire({
      title: 'Save',
      html: `<form class='publish-form'>
  <input class='title' type='text' placeholder='enter title' value='${data.title ? data.title : ""}'>
  <textarea class='description'>${desc}</textarea>
  <div class='images'>${imageTags}</div>
  </form>`,
      confirmButtonText: 'Save',
      didOpen: (el) => {
        el.querySelector(".images").addEventListener("click", (e) => {
          document.querySelectorAll(".images img").forEach((el2) => {
            el2.classList.remove("selected")
          })
          if (e.target.getAttribute("src")) e.target.classList.toggle("selected")
        })
      },
      preConfirm: async () => {
        let image = document.querySelector(".publish-form .images img.selected")
        let title = document.querySelector(".publish-form .title").value
        if (!title || title.length === 0) {
          alert("please enter title")
          return false;
        }
        try {
          // the first time creating a file,
          if (!this.src) {
            //does the title already exist?
            let slug = title.split().join("-").toLowerCase()
            let f = await fs.promises.stat(`${this.config.SRC}/${slug}`)
            // if already exists, return false
            alert("the file already exists")
            return false;
          }
        } catch (e) {
        }
        return [
          document.querySelector(".publish-form .title").value,
          document.querySelector(".publish-form .description").value,
          (image ? image.getAttribute("src") : null)
        ]
      }
    }).then((res) => {
      return {
        title: res.value[0],
        description: res.value[1],
        image: res.value[2]
      }
    })
    data.title = title
    data.description = description
    data.image = image
    data.updated = Date.now()
    let name
    let redirect = false;
    if (this.src) {
      name = this.src.split("/")[3]
    } else {
      name = uslug(title)
      this.src = `${this.config.SRC}/${name}`
      redirect = true;
    }
    data.permalink = name;
    let updatedContent = matter.stringify(content, data)
    await fs.promises.writeFile(`${this.config.SRC}/${data.permalink}`, updatedContent)
    await this.builder.buildPost(data.permalink, this.config)
    document.querySelector("#save").classList.remove("enabled")
    if (redirect) {
      location.href = "./editor?src=" + this.src
    } else {
      this.editor.setMarkdown(updatedContent)
    }
  }
  async destroy() {
    if (!this.src) return;
    let sure = confirm("are you sure?")
    if (sure) {
      // Delete files
      await fs.promises.unlink(this.src)
      let name = this.src.split("/")[2]
      await fs.promises.unlink(`${this.config.SRC}/${name}/index.html`).catch((e) => { })
      await fs.promises.rmdir(`${this.config.SRC}/${name}`).catch((e) => {})
      // remove from git too.
      let d = await this.deleted()
      for(let item of d) {
        await git.remove({ fs, dir: "/home", filepath: item[0] })
      }
      // Build
      await this.builder.build()
      location.href = "/upload"
    }
  }
};
var src = new URL(location.href).searchParams.get("src");
(async () => {
  let o = await fs.promises.readFile("/home/offbase.json", "utf8")
  let config = JSON.parse(o)

  await fs.promises.mkdir(config.settings.SRC).catch((e) => {})
  await fs.promises.mkdir(config.settings.DEST).catch((e) => {})
  await fs.promises.mkdir(`${config.settings.SRC}/assets`).catch((e) => {})
  await fs.promises.mkdir(`${config.settings.DEST}/assets`).catch((e) => {})

  // instantiate modules

//  let publishModules = []
//  for(let mod of config.events.publish) {
//    let o = await import(`./module/${mod}`)
//    publishModules.push(o.default) 
//  }

  var editor = new E({
    src: src,
    config: config.settings,
//    modules: {
//      publish: publishModules
//    }
  })
  document.querySelector("#delete").addEventListener("click", async (e) => {
    await editor.destroy()
  })
  document.querySelector("#unpublish").addEventListener("click", async (e) => {
    await editor.unpublish() 
  })
  document.querySelector("#upload").addEventListener("click", async (e) => {
    await editor.publish()
  })
  document.querySelector("#save").addEventListener("click", async (e) => {
    await editor.save()
  });
})();
</script>
</body>
</html>
