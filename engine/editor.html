<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.59.0/codemirror.min.css" />
<link rel="stylesheet" href="https://uicdn.toast.com/editor/latest/toastui-editor.min.css" />
<link rel='stylesheet' href="./style.css">
</head>
<body>
<nav>
<a class='brand' href='./'>Offbase</a>
<button id='save' class='button'>save</button>
<button id='delete' class='button'>delete</button>
<div class='flexible'></div>
<div class='draft hidden'>private</div>
<button id='unpublish' class='enabled'>unpublish</button>
<button id='upload' class='enabled'>publish</button>
</nav>
<div class='container'>
  <div id='editor'></div>
</div>
<script type='module'>
import Editor from "https://jspm.dev/@toast-ui/editor"
import Swal from "https://jspm.dev/sweetalert2"
import matter from "https://jspm.dev/gray-matter"
import { fs, git } from "/offbase.js"
import { Builder } from "./builder.js"
const slugify = (string) => {
  const a = 'àáâäæãåāăąçćčđďèéêëēėęěğǵḧîïíīįìłḿñńǹňôöòóœøōõőṕŕřßśšşșťțûüùúūǘůűųẃẍÿýžźż·/_,:;'
  const b = 'aaaaaaaaaacccddeeeeeeeegghiiiiiilmnnnnoooooooooprrsssssttuuuuuuuuuwxyyzzz------'
  const p = new RegExp(a.split('').join('|'), 'g')
  return string.toString().toLowerCase()
    .replace(/\s+/g, '-') // Replace spaces with -
    .replace(p, c => b.charAt(a.indexOf(c))) // Replace special characters
    .replace(/&/g, '-and-') // Replace & with 'and'
    .replace(/[^\w\-]+/g, '') // Remove all non-word characters
    .replace(/\-\-+/g, '-') // Replace multiple - with single -
    .replace(/^-+/, '') // Trim - from start of text
    .replace(/-+$/, '') // Trim - from end of text
}
const updated = async () => {
  const FILE = 0, HEAD = 1, WORKDIR = 2, STAGE = 3
  const filenames = (await git.statusMatrix({ fs, dir: "/" }))
    .filter((row) => {
      return !(row[HEAD] === 1 && row[WORKDIR] === 1 && row[STAGE] === 1)
    })
    .map(row => row[FILE])
  return filenames.length > 0
}
const deleted = async () => {
  const FILE = 0, HEAD = 1, WORKDIR = 2, STAGE = 3
  const filenames = (await git.statusMatrix({ fs, dir: "/" }))
    .filter((row) => {
      return row[WORKDIR] === 0
    })
  return filenames
}
class E {
  constructor (o) {
    this.src = o.src
    this.config = o.config
    this.builder = new Builder(fs, o.config)
    this.editor = new Editor({
      frontMatter: true,
      el: document.querySelector('#editor'),
      height: '100%',
      initialEditType: 'markdown',
      usageStatistics: false,
      previewStyle: 'vertical',
      events: {
        change: () => {
          document.querySelector("#save").classList.add("enabled")
        }
      },
      hooks: {
        addImageBlobHook: async (blob, callback) => {
          let ab = await blob.arrayBuffer()
          let bytes = new Uint8Array(ab)
          const hashBuffer = await crypto.subtle.digest('SHA-256', bytes)
          const hashArray = Array.from(new Uint8Array(hashBuffer));
          const hash = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
          await fs.promises.mkdir(`${this.config.SRC}/assets`).catch((e) => {
            console.log("e", e)
          })
          await fs.promises.writeFile(`${this.config.SRC}/assets/${hash}`, bytes).catch((e) => {
            console.log("e", e)
          })
          callback("assets/" + hash, hash)
          return false;
        }
      }
    });
    if (src) this.fill(decodeURIComponent(src))
  }
  fill (path) {
    fs.promises.readFile(path, "utf8").then((str) => {
      this.editor.setMarkdown(str)
      let parsed = matter(str)
      let md = parsed.content
      let metadata = parsed.data
      if (metadata.draft) {
        document.querySelector("#unpublish").classList.add("hidden")
        document.querySelector(".draft").classList.remove("hidden")
      }
    }).catch((e) => {
      console.log("error", e)
    })
  }
  async unpublish() {
    let raw = this.editor.getMarkdown()
    let parsed = matter(raw)
    let md = parsed.content
    let metadata = parsed.data
    metadata.draft = true
    let updatedContent = matter.stringify(md, metadata)
    await fs.promises.writeFile(this.src, updatedContent)
    await this.builder.build()
    setTimeout(() => {
      location.href = "/upload"
    }, 1000)
  }
  async publish() {
    let raw = this.editor.getMarkdown()
    let parsed = matter(raw)
    let md = parsed.content
    let metadata = parsed.data
    metadata.draft = false;
    console.log("metadata = ", metadata)
    let updatedContent = matter.stringify(md, metadata)
    await fs.promises.writeFile(this.src, updatedContent)
    let isupdated = await updated()
    if (!isupdated) {
      console.log("no update")
      alert("no update")
      return;
    }
    console.log("updated")
    await this.builder.build()
    setTimeout(() => {
      location.href = "/upload"
    }, 1000)
  }
  async save() {
    let raw = this.editor.getMarkdown()
    let parsed = matter(raw)
    let md = parsed.content
    let metadata = parsed.data
    let matches = raw.matchAll(/!\[.*?\]\((.*?)\)/g)
    let images = []
    for (let match of matches) {
      images.push(match[1])
    }
    let imageTags = images.map((image, i) => {
      if (i === 0) {
        return "<img class='selected' src='" + image + "'>"
      } else {
        return "<img src='" + image + "'>"
      }
    }).join("")

    let desc = (metadata.description ? metadata.description : document.querySelector(".tui-editor-contents").textContent.trim().replace(/(\r\n|\n|\r)/gm,"").slice(0, 300))
    let {title, description, image} = await Swal.fire({
      title: 'Save',
      html: `<form class='publish-form'>
  <input class='title' type='text' placeholder='enter title' value='${metadata.title ? metadata.title : ""}'>
  <textarea class='description'>${desc}</textarea>
  <div class='images'>${imageTags}</div>
  </form>`,
      confirmButtonText: 'Save',
      didOpen: (el) => {
        el.querySelector(".images").addEventListener("click", (e) => {
          document.querySelectorAll(".images img").forEach((el2) => {
            el2.classList.remove("selected")
          })
          if (e.target.getAttribute("src")) {
            e.target.classList.toggle("selected")
          }
        })
      },
      preConfirm: async () => {
        let image = document.querySelector(".publish-form .images img.selected")
        let title = document.querySelector(".publish-form .title").value
        if (!title || title.length === 0) {
          alert("please enter title")
          return false;
        }
        try {
          // the first time creating a file,
          if (!this.src) {
            //does the title already exist?
            let slug = title.split().join("-").toLowerCase()
            let f = await fs.promises.stat(`${this.config.SRC}/${slug}`)
            // if already exists, return false
            alert("the file already exists")
            return false;
          }
        } catch (e) {
        }
        return [
          document.querySelector(".publish-form .title").value,
          document.querySelector(".publish-form .description").value,
          (image ? image.getAttribute("src") : null)
        ]
      }
    }).then((res) => {
      return {
        title: res.value[0],
        description: res.value[1],
        image: res.value[2]
      }
    })
    console.log("title", title)
    console.log("description", description)
    console.log("image", image)
    metadata.title = title
    metadata.description = description
    metadata.image = image
    metadata.updated = Date.now()

    let name
    let redirect = false;
    if (this.src) {
      name = this.src.split("/")[3]
    } else {
      name = slugify(title)
      this.src = `${this.config.SRC}/${name}`
      redirect = true;
    }
    //metadata.permalink = name.split().join("-").toLowerCase()
    metadata.permalink = name

    // if draft attribute does not exist, set it to true
    // otherwise, ignore
    if (!metadata.hasOwnProperty("draft")) {
      metadata.draft = true
    }

    let updatedContent = matter.stringify(md, metadata)

    await fs.promises.writeFile(`${this.config.SRC}/${metadata.permalink}`, updatedContent)


    console.log("start build")
//    await build(M, fs, metadata.permalink)
    console.log("built")

    document.querySelector("#save").classList.remove("enabled")
    if (redirect) {
      setTimeout(() => {
        location.href = "./editor?src=" + this.src
      }, 1000)
    } else {
      this.editor.setMarkdown(updatedContent)
    }
  }
  async destroy() {
    if (!this.src) {
      return;
    }
    let sure = confirm("are you sure?")
    if (sure) {
      // delete the file
      await fs.promises.unlink(this.src)

      // delete the corresponding dest files
      let name = this.src.split("/")[2]
      await fs.promises.unlink(`${this.config.SRC}/${name}/index.html`).catch((e) => { })
      await fs.promises.rmdir(`${this.config.SRC}/${name}`).catch((e) => {})

      // remove from git too.
      let d = await deleted()
      for(let item of d) {
        await git.remove({ fs, dir: "/home", filepath: item[0] })
        console.log("removed", item[0])
      }
      await this.builder.build()
      setTimeout(() => {
        location.href = "/upload"
      }, 1000)
    }
  }
}

var src = new URL(location.href).searchParams.get("src")
var editor = new E({
  src: src,
  config: {
    SRC: "/home/src",
    DEST: "/home/blog",
    NAME: "Twiddler",
    BASE: "https://fingertwiddler.github.io/test/blog/",
    THEME: {
      HOME: "/theme/dashboard.hbs",
      POST: "/theme/post.hbs"
    }
  }
})
document.querySelector("#delete").addEventListener("click", async (e) => {
  editor.destroy()
})
document.querySelector("#unpublish").addEventListener("click", async (e) => {
  await editor.unpublish() 
})
document.querySelector("#upload").addEventListener("click", async (e) => {
  await editor.publish()
})
document.querySelector("#save").addEventListener("click", async (e) => {
  await editor.save()
});

</script>
</body>
</html>
